@inject IJSRuntime JSRuntime

<div class="video-container" @ref="_container" @ontouchstart="OnTouchStart" @ontouchend="OnTouchEnd">
    <video-js id="@_playerId" class="video-js" controls preload="metadata">
        <source src="@Source" type="application/x-mpegURL" />
    </video-js>
</div>

<style>
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
    }
    
    .video-container {
        width: 100%;
        height: 100vh;
        overflow: hidden;
        position: relative;
        background: #000;
    }

    .video-container .video-js {
        width: 100%;
        height: 100%;
        position: relative;
        will-change: transform;
        transform: translateZ(0);
    }

    .video-container .vjs-tech {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        object-fit: cover;
        object-position: center;
    }

    .video-container .vjs-control-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 2;
        background: rgba(0,0,0,0.7);
    }

    .video-js .vjs-menu {
        right: 0 !important;
        left: auto !important;
        overflow: visible !important;
    }

    .video-js .vjs-big-play-button {
        z-index: 2;
    }
</style>

@code {
    private readonly string _playerId = $"player-{Guid.NewGuid():N}";
    private ElementReference _container;
    private IJSObjectReference? _module;
    private DotNetObjectReference<StreamVideo>? _selfReference;
    private DateTime _touchStartTime;
    private double _touchStartY;

    [Parameter]
    public string Source { get; set; } = "";

    private void OnTouchStart(TouchEventArgs e)
    {
        _touchStartTime = DateTime.Now;
        _touchStartY = e.Touches[0].ClientY;
    }

    private async Task OnTouchEnd(TouchEventArgs e)
    {
        var touchDuration = DateTime.Now - _touchStartTime;
        var touchEndY = e.ChangedTouches[0].ClientY;
        var touchDistance = Math.Abs(touchEndY - _touchStartY);

        // Only count as a tap if:
        // 1. Touch was short (less than 200ms)
        // 2. Didn't move much vertically (less than 10px)
        if (touchDuration.TotalMilliseconds < 200 && touchDistance < 10)
        {
            try
            {
                await JSRuntime.InvokeVoidAsync("toggleVideo", _playerId);
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("console.error", "Error toggling video:", ex.Message);
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _selfReference = DotNetObjectReference.Create(this);
                _module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "/js/stream.js");
                
                await JSRuntime.InvokeVoidAsync("initializePlayer", _playerId, new
                {
                    preload = "metadata",
                    loadingSpinner = false,
                    controls = true,
                    controlBar = new
                    {
                        fullscreenToggle = false,
                        pictureInPictureToggle = false
                    }
                });

                await _module.InvokeVoidAsync("observeVideoVisibility", _container, _selfReference);
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("console.error", "Error initializing video player:", ex.Message);
            }
        }
    }

    [JSInvokable]
    public async Task OnVisibilityChanged(bool isVisible)
    {
        try
        {
            if (isVisible)
            {
                // Only play if any video is currently playing (user has started playback)
                await JSRuntime.InvokeVoidAsync("playVideoIfActive", _playerId);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("pauseVideo", _playerId);
            }
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.error", "Error handling visibility change:", ex.Message);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_module is not null)
        {
            await _module.DisposeAsync();
        }
        _selfReference?.Dispose();
        await JSRuntime.InvokeVoidAsync("disposePlayer", _playerId);
    }
} 